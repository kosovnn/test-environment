#! /bin/bash
# SPDX-License-Identifier: Apache-2.0
#
# Test Coverage Estimation
# Process TCE for all NUT images
#
#
# Copyright (C) 2004-2022 OKTET Labs Ltd. All rights reserved.

SCRIPT_DIR=`dirname $0`

. "${SCRIPT_DIR}/te_tce_functions.sh"

TCE_LIST="$1"

tce_set_build_base \
    || tce_die "failed to locate base directories for builds"

for platform in $TE_BS_PLATFORMS; do
    tce_list="$(tce_list_components "${platform}")"
    fake_sbd=
    if test -n "$tce_list" -a -f "${TE_BUILD}/${platform}.sbd"; then
        # When shadow build directory is used, GCOV data files will be
        # created in that directory, instead of the normal build directory.
        # That's a limitation of GCC+GCOV which in principle can be
        # circumvented by a combination of GCC scripts and environment
        # variables, but it seems like this way is simpler and more reliable
        sbd="$(cat "${TE_BUILD}/${platform}.sbd")"
        if test "${sbd}" != "${TE_BUILD}"; then
            te_eval_or_ssh "${platform}" "
               sudo tar -C '${sbd}' -czf - . ;
               sudo rm -rf '${sbd}' >/dev/null
            " | tar -C "${TE_BUILD}" -xzf -
            # The build directory may contain files with profilable code,
            # e.g. headers with inline functions.
            # If a shadow build directory has been used, it will be searched
            # by gcov, so we create a local fake symlink to it
            ln -s "${TE_BUILD}" "${sbd}"
            fake_sbd=1
        fi
    fi
    for tce in $tce_list ; do
        srcvar="TE_BS_TCE_${platform}_${tce}_SOURCES"
        if test -z "${!srcvar}"; then
            echo "warning: TCE component $tce not defined for platform $platform" >&2
            continue
        fi
        buildvar="TE_BS_TCE_${platform}_${tce}_MESON_BUILDDIR"
        if ! test -d "${!buildvar}" ; then
            buildvar="TE_BS_TCE_${platform}_${tce}_BUILDDIR"
            if ! test -d "${!buildvar}" ; then
                echo "warning: TCE component $tce not built for platform $platform @ ${!buildvar}" >&2
                continue
            fi
        else
            continue
        fi
        find "${!buildvar}" -name '*.da' -o -name '.*.da' -o -name '*.gcda' -o -name '.*.gcda' | \
            xargs -r -n1 tce_gcov "${!buildvar}" || exit 1
        find "${!buildvar}" -name '*.gcov' -o -name '.*.gcov' | sort | \
            xargs -r -n1 tce_report >${TE_LOG_DIR}/tce_log_${platform}_${tce}.tce || exit 1
        mkdir -p ${TE_LOG_DIR}/tce_log_${platform}_${tce}_files
        excludevar="TE_BS_TCE_${platform}_${tce}_EXCLUDESRC"
        (cd "${!buildvar}";
         tce_summary -vEXCLUDE="${!excludevar}" -vSORTMODE=coverage \
                     -vDATADIR=${TE_LOG_DIR}/tce_log_${platform}_${tce}_files \
                     ${TE_LOG_DIR}/tce_log_${platform}_${tce}.tce > \
                     ${TE_LOG_DIR}/tce_log_${platform}_${tce}.html)
    done
    test -n "$fake_sbd" && rm -f "$sbd"
done

tce_set_type_comp_build

function parse_ta_list_line
{
    local _map=$1
    shift
    local line=( $@ )
    local platform="${line[2]}"
    local host="${line[1]}"
    local hosts=

    test \( -n "${platform}" \) -a \( -n "${host}" \) || \
        return 1

    hosts="$(eval echo "\${${_map}[${platform}]}")"
    hosts="${hosts}${hosts:+ }${host}"

    eval "${_map}[${platform}]=\"${hosts}\""
}

function map_platform_to_hosts
{
    local ta_file="${TE_TA_LIST_FILE}"
    local line=
    declare -gA platform_hosts

    while read line ; do
        test -n "$line" || \
            continue
        parse_ta_list_line platform_hosts "$line" || \
            tce_die "fail to parse the list of TA hosts"
    done < "${ta_file}" || \
        tce_die "fail to read the list of TA hosts"
}

map_platform_to_hosts

function set_platform_host_ssh
{
    local platform=$1
    local host=$2
    local p_host_ssh="${platform}_${host}_SSH"
    local host_ssh="${!p_host_ssh}"
    local p_ssh="${platform}_SSH"
    local ssh="${!p_ssh}"

    test -n "$host_ssh" && \
        return 0

    host_ssh=$(echo "${ssh}" | sed "s/ [^ ]\+$/ ${host}/")

    export ${p_host_ssh}="${host_ssh}"
}

function check_host_dir
{
    local platform="$1"
    local host="$2"
    local dir="$3"
    local rc=

    te_eval_or_ssh "${platform}_${host}" \
                   "test -d \"$dir\""
    rc=$?

    case $rc in
    0|1)
        return $rc
        ;;
    *)
        tce_die "fail to check directory: " \
                "platform ${platform} host {$host}"
        ;;
    esac
}

function rsync_fnmatch_from
{
    local fnm="$1"
    local platform="$2"
    local src="$3"
    local dst="$4"
    local p_ssh="${platform}_SSH"
    local ssh="${!p_ssh}"
    local rsync="rsync -a --include=${fnm} --include=*/ --exclude=*"

    if test -n "${ssh}" ; then
        ${rsync} -e "${ssh% *}" "${ssh##* }:${src}/" "${dst}/"
    else
        ${rsync} "${src}/" "${dst}/"
    fi
}

function rsync_fnmatch_to
{
    local fnm="$1"
    local platform="$2"
    local src="$3"
    local dst="$4"
    local p_ssh="${platform}_SSH"
    local ssh="${!p_ssh}"
    local rsync="rsync -a --include=${fnm} --include=*/ --exclude=*"

    if test -n "${ssh}" ; then
        ${rsync} -e "${ssh% *}" "${src}/" "${ssh##* }:${dst}/"
    else
        ${rsync} "${src}/" "${dst}/"
    fi
}

#######################################
# Form the name of directory to process a TA component.
#
# This function is added to update a legacy text. And will be removed after the
# TCE processing will use the TCE information saved by the RCF controller.
# Does not use it in a new text!
#
# Arguments:
#   The TA type of the component.
#   The TA host the component has been fetced.
#   The name of a TA component.
# Outputs:
#   Outputs the name of the directory.
#######################################
function tce_ws_name() {
    local type=$1
    local host=$2
    local comp=$3

    echo "${type}_${host}_${comp}"
}

function tce_ws_dir
{
    local platform=$1
    local host=$2
    local tce=$3

    echo "${TCE_WS}/$(tce_ws_name "${platform}" "${host}" "${tce}")"
}

function fetch_host_tce
{
    local platform=$1
    local host=$2
    local tce=$3
    local hostdir="${tce_build_base[${platform}]}"
    local tcedir="$(tce_ws_dir "${platform}" "${host}" "${tce}")"
    local build="${tce_type_comp_build["${platform}_${tce}"]}"

    mkdir -p "${tcedir}/build" || \
        tce_die "fail to create directory to save TCE: " \
                "platform ${platform} host ${host} tce ${tce}"

    # Check TCE provided by a host
    check_host_dir ${platform} ${host} "${hostdir}/${build}" || \
        return 0

    rsync_fnmatch_from "*.gcda" "${platform}_${host}" "${hostdir}/${build}" \
                       "${tcedir}/build" || \
        tce_die "fail to fetch TCE: " \
                "platform ${platform} host ${host} tce ${tce}"
}

#######################################
# Clean TCE files on the build host.
# Globals:
#   tce_build_base
#   tce_type_comp_build
# Arguments:
#   The TA type.
#   The name of a TA component.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_clean_on_host() {
    local type="$1"
    local comp="$2"
    local hbase="${tce_build_base[${type}]}"
    local hdest="${hbase}/destdir/${TE_INSTALL}/${type}"
    local build="${tce_type_comp_build["${type}_${comp}"]}"

    te_eval_or_ssh "${type}" "
                   export PATH=\"${hdest}/bin:\${PATH}\" ;
                   te_clean_gcov.sh \"${hbase}/${build}\"
                   " \
        || tce_die "failed to clean ${type}/${comp} on build host"
}

#######################################
# Process gcda files on the build host
# Globals:
#   TE_INSTALL
#   TCE_WS
#   tce_build_base
#   tce_type_comp_build
# Arguments:
#   The TA type.
#   The name of a TA component.
#   The destination of gcda files.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_process_gcda_on_host() {
    local type="$1"
    local comp="$2"
    local dest="$3"
    local hbase="${tce_build_base[${type}]}"
    local hdest="${hbase}/destdir/${TE_INSTALL}/${type}"
    local build="${tce_type_comp_build[${type}_${comp}]}"

    tce_clean_on_host "${type}" "${comp}"

    rsync_fnmatch_to "*.gcda" "${type}" "${TCE_WS}/${dest}/build" \
                     "${hbase}/${build}" \
        || tce_die "failed to place ${dest} on ${type}/${comp} build host"

    te_eval_or_ssh "${type}" "
                   export PATH=\"${hdest}/bin:\${PATH}\" ;
                   te_process_gcov.sh \"${hbase}/${build}\" " \
        || tce_die "failed to process ${dest} on ${type}/${comp} build host"

    rsync_fnmatch_from "*.gcov" "${type}" "${hbase}/${build}" \
                       "${TCE_WS}/${dest}/build" \
        || tce_die "failed to fetch ${dest} from ${type}/${comp} build host"
}

#######################################
# Link the source directory to be relative to the build.
# Globals:
#   TE_BS_TCE_${type}_${comp}_SOURCES
#   TE_BUILD
#   tce_type_comp_build
# Arguments:
#   The TA type of build.
#   The name of a TA component.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_link_src_on_build() {
    local type="$1"
    local comp="$2"
    local build="${tce_type_comp_build[${type}_${comp}]}"
    local pbase="${TE_BUILD}/platforms/${type}"
    local psrc="TE_BS_TCE_${type}_${comp}_SOURCES"

    [[ -d "${pbase}/${build}/../src" ]] && return 0

    [[ -d "${!psrc}" ]] \
        || tce_die "failed to locate src for ${type}/${comp}"

    ln -s "${!psrc}" "${pbase}/${build}/../src" \
        || tce_die "failed to link src for ${type}/${comp}"
}

#######################################
# Link the inst directory to be relative to the build.
# Globals:
#   TE_BUILD
#   TE_INSTALL
#   tce_type_comp_build
# Arguments:
#   The TA type of build.
#   The name of a TA component.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_link_inst_on_build() {
    local type="$1"
    local comp="$2"
    local build="${tce_type_comp_build[${type}_${comp}]}"
    local pbase="${TE_BUILD}/platforms/${type}"
    local inst="$(realpath "${pbase}/${build}/../inst")"

    [[ -d "${inst}" ]] && return 0

    [[ -d "${TE_INSTALL}/${type}" ]] \
        || tce_die "failed to locate inst for ${type}/${comp}"

    ln -s "${TE_INSTALL}/${type}" "${inst}" \
        || tce_die "failed to link inst for ${type}/${comp}"
}

#######################################
# Resolve gcov sources to be relative to the build
# Globals:
#   TE_BUILD
#   TE_INSTALL
#   TCE_WS
#   tce_build_base
#   tce_type_comp_build
# Arguments:
#   The TA type of build.
#   The name of a TA component.
#   The destination of gcov files.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_resolve_gcov_on_build() {
    local type="$1"
    local comp="$2"
    local dest="$3"
    local hbase="${tce_build_base[${type}]}"
    local build="${tce_type_comp_build[${type}_${comp}]}"
    local pbase="${TE_BUILD}/platforms/${type}"
    local conf="${TCE_WS}/${dest}/tce.conf"

    cat 2> /dev/null > "${conf}" << EOF
{
    "build" : "${build}",
    "inst" : "../inst",
    "plat_build" : "${pbase}/${build}",
    "host_build" : "${hbase}/${build}",
    "host_inst" : "${hbase}/destdir/${TE_INSTALL}/${type}",
    "unres" : "unres.txt"
}
EOF
    (( $? == 0 )) \
        || tce_die "failed to write ${dest} configuration for ${type}/${comp}"

    tce_resolve_gcov.py "${conf}" \
        || tce_die "failed to resolve ${dest} gcov files for ${type}/${comp}"
}

tce_py="${TE_INSTALL}/${TE_HOST}/lib"
export PYTHONPATH="${tce_py}:${PYTHONPATH}"

for platform in "${!tce_type_comp[@]}" ; do
    tce_list="${tce_type_comp[${platform}]}"
    hosts="${platform_hosts[${platform}]}"

    for host in ${hosts} ; do
        set_platform_host_ssh ${platform} ${host}

        for tce in ${tce_list} ; do
            fetch_host_tce ${platform} ${host} ${tce}
        done
    done

    for host in ${hosts} ; do
        for tce in ${tce_list} ; do
            tce_process_gcda_on_host "${platform}" "${tce}" \
                    "$(tce_ws_name "${platform}" "${host}" "${tce}")"
        done
    done

    for tce in ${tce_list} ; do
        tce_link_src_on_build "${platform}" "${tce}"
        tce_link_inst_on_build "${platform}" "${tce}"

        for host in ${hosts} ; do
            tce_resolve_gcov_on_build "${platform}" "${tce}" \
                    "$(tce_ws_name "${platform}" "${host}" "${tce}")"
        done
    done
done

function get_tce_platforms
{
    local tce=$1
    local platform=
    local tce_list=
    local platforms=

    for platform in "${!tce_type_comp[@]}" ; do
        tce_list="${tce_type_comp[${platform}]}"
        test "${tce_list/${tce}/ }" != "$tce_list" && \
            platforms+="${platform} "
    done

    echo "${platforms}"
}

#######################################
# Clean gcda and gcov files on the build.
# Globals:
#   TE_BUILD
#   tce_type_comp_build
# Arguments:
#   The TA type of build.
#   The name of a TA component.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_clean_on_build() {
    local type="$1"
    local comp="$2"
    local pbase="${TE_BUILD}/platforms/${type}"
    local build="${tce_type_comp_build[${type}_${comp}]}"
    local files=
    local f=

    pushd "${pbase}/${build}" &> /dev/null \
        || tce_die "failed to locate ${type}/${comp} build"

    files="$(find . -name \*.gcda -o -name \*.gcov 2> /dev/null)" \
        || tce_die "failed to locate gcda/gcov files on ${type}/${comp} build"

    while read f ; do
        [[ -z "$f" ]] && continue

        rm --interactive=never "$f" 2> /dev/null \
            || tce_die "failed to remove $f on ${type}/${comp} build"
    done < <(echo "${files}")

    popd > /dev/null
}

#######################################
# Copy gcov files to the build.
# Globals:
#   TE_BUILD
#   TCE_WS
#   tce_type_comp_build
# Arguments:
#   The TA type of build.
#   The name of a TA component.
#   The destination of gcov files.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_copy_gcov_to_build() {
    local type="$1"
    local comp="$2"
    local dest="$3"
    local pbase="${TE_BUILD}/platforms/${type}"
    local build="${tce_type_comp_build[${type}_${comp}]}"

    tce_clean_on_build "${type}" "${comp}"

    [[ -d "${TCE_WS}/${dest}/build" ]] \
        || tce_die "failed to locate ${dest} gcov files for ${type}/${comp} " \
                   "build"

    rsync -a --include=\*.gcov --include=\*/ --exclude=\* \
          "${TCE_WS}/${dest}/build/" "${pbase}/${build}/" 2> /dev/null \
        || tce_die "failed to place ${dest} gcov files on ${type}/${comp} build"
}

#######################################
# Generate the TCE report.
# Globals:
#   TE_BUILD
#   TCE_WS
#   tce_type_comp_build
# Arguments:
#   The TA type of build.
#   The name of a TA component.
#   The destination of gcov files.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_create_report() {
    local type="$1"
    local comp="$2"
    local dest="$3"
    local pbase="${TE_BUILD}/platforms/${type}"
    local build="${tce_type_comp_build[${type}_${comp}]}"
    local report="${TCE_WS}/${dest}/report.tce"
    local files=
    local f=

    > "${report}" \
        || tce_die "failed to clean TCE report for ${type}/${comp}"

    pushd "${pbase}/${build}" &> /dev/null \
        || tce_die "failed to locate build for ${type}/${comp}"

    files="$(find . -name \*.gcov 2> /dev/null)" \
        || tce_die "failed to list gcov files for ${type}/${comp}"

    while read f ; do
        [[ -z "$f" ]] && continue

        cat "$f" | tce_report >> "${report}" \
            || tce_die "failed to report TCE file $f for ${type}/${comp}"
    done < <(echo "${files}" | sort)

    popd > /dev/null
}

function summarise_tce
{
    local platform=$1
    local host=$2
    local tce=$3
    local repname="$4"
    local tcedir="$(tce_ws_dir "${platform}" "${host}" "${tce}")"
    local report="${tcedir}/report.tce"
    local build="${tce_type_comp_build["${platform}_${tce}"]}"
    local wsdir="${TE_BUILD}/platforms/${platform}"
    local p_excl="TE_BS_TCE_${platform}_${tce}_EXCLUDESRC"
    local excl="${!p_excl}"
    local resbase="${TE_LOG_DIR}/${repname}"

    test -d "${resbase}_files" && \
        rm -r "${resbase}_files"

    mkdir -p "${resbase}_files"

    pushd "${wsdir}/${build}" > /dev/null || \
        tce_die "fail to locate platform to summarise TCE: " \
                "platform ${platform} host ${host} tce ${tce}"

    tce_summary -vEXCLUDE="${excl}" -vSORTMODE=coverage \
                -vDATADIR="${resbase}_files" \
                "${report}" > \
                "${resbase}.html" || \
        tce_die "fail to create summary for TCE report" \
                "platform ${platform} host ${host} tce ${tce}"

    popd > /dev/null
}

#######################################
# Merge a TCE report.
# Globals:
#   TCE_WS
# Arguments:
#   The directory with the report to be merged.
#   The directory to merge into.
# Outputs:
#   Outputs a message on an error.
# Returns:
#   This function never returns on an error.
#######################################
function tce_merge_report() {
    local src="$1"
    local dest="$2"
    local conf="${TCE_WS}/${src}/tce.conf"
    local rep="${TCE_WS}/${src}/report.tce"
    local mconf="${TCE_WS}/${dest}/tce.conf"
    local mrep="${TCE_WS}/${dest}/report.tce"

    if [[ ! -f "${mrep}" ]] ; then
        mkdir -p "${TCE_WS}/${dest}" 2> /dev/null
        touch "${mrep}" 2> /dev/null
        cp "${conf}" "${mconf}" \
            || tce_die "failed to copy TCE conf from ${src}"
    fi

    tce_merge_report.py "${mconf}" "${mrep}" "${conf}" "${rep}" \
        || tce_die "failed to merge TCE report from ${src}"
}

all_tce="$(echo "${tce_type_comp[@]}" | sed 's/ \+/\n/g' | sort -u)"

for tce in $all_tce ; do
    platforms="$(get_tce_platforms ${tce})"
    platform=
    hosts=
    host=
    mplatform=

    for platform in ${platforms} ; do
        hosts="${platform_hosts[${platform}]}"

        for host in ${hosts} ; do
            repname="tce_log_${platform}_${host}_${tce}"

            tce_copy_gcov_to_build "${platform}" "${tce}" \
                    "$(tce_ws_name "${platform}" "${host}" "${tce}")"
            tce_create_report "${platform}" "${tce}" \
                    "$(tce_ws_name "${platform}" "${host}" "${tce}")"
            summarise_tce ${platform} ${host} ${tce} "${repname}"
        done
    done

    for platform in ${platforms} ; do
        hosts="${platform_hosts[${platform}]}"

        for host in ${hosts} ; do
            [[ -z "${mplatform}" ]] && mplatform="${platform}"

            tce_merge_report "$(tce_ws_name "${platform}" "${host}" "${tce}")" \
                             "$(tce_ws_name "${mplatform}" "" "${tce}")"
        done
    done

    repname="tce_log_${tce}"
    summarise_tce ${mplatform} "" ${tce} "${repname}"
done
